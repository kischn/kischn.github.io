# 聊聊缓存

## 先说观点

当今高性能的 `Redis` 在 `互联网` 上的流行，产生了一个比较极端的现象，那就是不管啥项目就直接无脑上 `Redis`。在我看来这种行为很 Low，缺乏思考，仅仅为了缓存个东西就引入这么一个复杂的组件。  
曾经自己也是不以为事，后来兼职了一段时间的运维才发现，光是维护 `Redis` 就挺费精力，所以现在我觉得需要好好思考一下: 什么时候用 `Redis` 才算得上合理呢？我个人有一个挺有槽点的观点：`当你认定自己已经没有更好的优化方案的时候 —— 也就是 loser 才用 Redis 缓存` 。

## 高性能的 Redis

不想用不代表不会用, 也不代表 `Redis` 不好，只是当前场景用还为时过早。  
不可否认的是 `Redis` 的确是一款性能非常高的组件，它是用 C 语言写的、单线程的、支持持久化的缓存组件。很多的场景开发人员只需要使用几个 Redis 命令就能简单实现，可以说是很方便了，下面举几个例子分析一下。

> 所有可用的 Redis 命令可以通过 `https://redis.io/commands` 自己去查找，上面还有分组。

### 键值存储

这个使用可以说是最常见的使用方式了，就是把 `key` 与 `value` 放进去，再根据 `key` 去取，非常简单。
有一个比较有用的命令是 `SETNX` (set if not exsits) 命令，只有对应的 `key` 不存在的时候才会放进去，类似于 `HashMap` 里面的 `putIfAbsent` ，**这个命令常用于分布式锁**。

### 计数

[INCR](https://redis.io/commands/incr), 不用讲太多，就是 `+1` 用的, **场景就是阅读数啊、点赞数啊什么的**。

### 队列

Redis 支持列表相关操作，操作命令就是 `Lpop|Rpop|Lpush|Rpush {listName} {value}`。分别就是从左/右侧放入或取出。
如果一个程序只 `pop` 另一些程序 `push` 那不就是一个**简单的队列**了嘛。

### 功能还有很多，不一一讲了

## 引入 Redis 的成本分析

### 技术成本

1. `Redis` 有一套自己的命令需要去了解和学习才能使用，增加了负担。  

2. 需要引入额外的类库。

3. 引入缓存，就需要解决缓存的失效和更新问题，排查项目问题的时候难度也会增大。

### 运维成本

1. 环境部署时需要额外部署一套 `Redis` 实例，增加了项目复杂性。

2. 想要运维好 `Redis` 需要了解 `Redis` 的内存规划、刷盘策略(快照或增量)。

3. `Redis` 不好监控和数据分析，通过分析 `Redis` 来判断项目里面是否有合理使用需要额外的精力。

### 风险成本

1. 每引入一个新的服务，就会增加额外的风险点。项目曾使用某私有云提供的 `Redis` 服务就出现过服务不可用问题, 当然它也出现过 企业微信接口不可用、RDS 服务不可用的情况, 这也印证了前面那句话。

2. 同运维成本一样，`Redis` 需要额外的监控，如果做不到监控，出现问题后就会影响到项目。

### 已有成本

这是我自己发明的词，就是要分析一下我们要通过引入 `Redis` 去解决的那个问题，用已有的服务能不能解决？答案是能, 用 `MySQL`。  
我们是不是可以只需要维护好 `MySQL` 就能解决当前的绝大部分缓存问题了呢？我们需要先同步一下看法：什么是缓存？

## 缓存的几种分类

缓存嘛，就是把计算结果暂存一下，省得每次都需要去计算，节省时间。比如 `CPU` 嫌 `IO` 太慢了，所以搞了三层缓存(L1, L2, L3)，再加上内存、硬盘，一层比一层慢。  
而我们的接口，尤其是查询统计接口，大数据范围查询汇总的时候总是会很慢，所以不得以为了提高接口的响应速度我们需要缓存来把查询结果暂存一下，但是呢，加了缓存只是第一步，因为不加预处理的话，接口第1次查询还是会很慢，所以我们还需要一个定时任务在项目启动后就提前查询一次……不得不说，这有点复杂了, 有没有更好的方法？

### 没有缓存(优化索引)

当一个查询很慢的时候，首先要想到的肯定是加索引，而不是加缓存，如果能通过合理的索引去解决这个问题缓存就完全没必要了，因为缓存还存在数据实时性的问题。

### 数据汇总表

当简单的添加索引解决不了查询慢的问题的时候，我们再想到这一步：是不是基础数据量太大了，可不可以单独整一个汇总表，也就是对数据先进行一层数据汇总。  
当然，并不是所有的数据都可以进行数据汇总，我们一般只能对那种变化很少的数据进行这种处理，比如登录日志。我们有一个登录记录表，记录每一次的登录信息，但是这个表进行按月、按季甚至按年统计的时候数据量就太大了，查询时间肯定快不了。所以我们就可以建一个 月汇总表甚至再建一个年汇总表，而且甚至可以用一下互联网经验里面的**大忌**：`触发器`。当有登录数据插入时，顺便去月汇总表、季表里面去插入或更新一下就可以了，复杂性大大降低,这样查询的时候也是实时的数据结果。

> 数据库是值得信任的

### 缓存计算

这个就是最常见的场景了，已经拿不出啥好优化的方式了(黔驴技穷了, 这也对应上面的 `loser` 认怂了)，只能是接口先计算，然后把计算结果找一个地方缓存一下，牺牲实时性，通过定时任务定时去刷新结果。
坏处是需要额外的定时任务，一定程度上增加了项目复杂度。比如:  

* 突然想刷新一下缓存？

* 现在想部署多个实例，任务重复了咋办？

* 我想变更一下定时任务的时间安排？

只有走到这一步的时候，才有这个需求去考虑一下 `Redis`，但是在它之前，还有一个 `MySQL` 的 `memory table` 可以用。

//TODO 讲讲 MySQL 的 memory 引擎

## 结论  

1. 尽量少的去使用缓存，尽量在设计阶段就避免瓶颈问题。

2. 如果需要缓存，先看看 `MySQL` 的 `memory engine` 能否满足性能需求。

3. 用 `Redis`( `Java` 内存缓存也是下下策，仅用于非常临时的缓存，否则还不如 `Redis`，至少 `Redis` 还能从外部删除或更新)。
